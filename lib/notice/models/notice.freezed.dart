// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'notice.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Notice {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() announcement,
    required TResult Function() notification,
    required TResult Function() warning,
    required TResult Function() following,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? announcement,
    TResult? Function()? notification,
    TResult? Function()? warning,
    TResult? Function()? following,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? announcement,
    TResult Function()? notification,
    TResult Function()? warning,
    TResult Function()? following,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Announcement value) announcement,
    required TResult Function(_Notification value) notification,
    required TResult Function(_Warning value) warning,
    required TResult Function(_Following value) following,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Announcement value)? announcement,
    TResult? Function(_Notification value)? notification,
    TResult? Function(_Warning value)? warning,
    TResult? Function(_Following value)? following,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Announcement value)? announcement,
    TResult Function(_Notification value)? notification,
    TResult Function(_Warning value)? warning,
    TResult Function(_Following value)? following,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NoticeCopyWith<$Res> {
  factory $NoticeCopyWith(Notice value, $Res Function(Notice) then) =
      _$NoticeCopyWithImpl<$Res, Notice>;
}

/// @nodoc
class _$NoticeCopyWithImpl<$Res, $Val extends Notice>
    implements $NoticeCopyWith<$Res> {
  _$NoticeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Notice
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$AnnouncementImplCopyWith<$Res> {
  factory _$$AnnouncementImplCopyWith(
          _$AnnouncementImpl value, $Res Function(_$AnnouncementImpl) then) =
      __$$AnnouncementImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AnnouncementImplCopyWithImpl<$Res>
    extends _$NoticeCopyWithImpl<$Res, _$AnnouncementImpl>
    implements _$$AnnouncementImplCopyWith<$Res> {
  __$$AnnouncementImplCopyWithImpl(
      _$AnnouncementImpl _value, $Res Function(_$AnnouncementImpl) _then)
      : super(_value, _then);

  /// Create a copy of Notice
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$AnnouncementImpl implements _Announcement {
  const _$AnnouncementImpl();

  @override
  String toString() {
    return 'Notice.announcement()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AnnouncementImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() announcement,
    required TResult Function() notification,
    required TResult Function() warning,
    required TResult Function() following,
  }) {
    return announcement();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? announcement,
    TResult? Function()? notification,
    TResult? Function()? warning,
    TResult? Function()? following,
  }) {
    return announcement?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? announcement,
    TResult Function()? notification,
    TResult Function()? warning,
    TResult Function()? following,
    required TResult orElse(),
  }) {
    if (announcement != null) {
      return announcement();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Announcement value) announcement,
    required TResult Function(_Notification value) notification,
    required TResult Function(_Warning value) warning,
    required TResult Function(_Following value) following,
  }) {
    return announcement(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Announcement value)? announcement,
    TResult? Function(_Notification value)? notification,
    TResult? Function(_Warning value)? warning,
    TResult? Function(_Following value)? following,
  }) {
    return announcement?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Announcement value)? announcement,
    TResult Function(_Notification value)? notification,
    TResult Function(_Warning value)? warning,
    TResult Function(_Following value)? following,
    required TResult orElse(),
  }) {
    if (announcement != null) {
      return announcement(this);
    }
    return orElse();
  }
}

abstract class _Announcement implements Notice {
  const factory _Announcement() = _$AnnouncementImpl;
}

/// @nodoc
abstract class _$$NotificationImplCopyWith<$Res> {
  factory _$$NotificationImplCopyWith(
          _$NotificationImpl value, $Res Function(_$NotificationImpl) then) =
      __$$NotificationImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotificationImplCopyWithImpl<$Res>
    extends _$NoticeCopyWithImpl<$Res, _$NotificationImpl>
    implements _$$NotificationImplCopyWith<$Res> {
  __$$NotificationImplCopyWithImpl(
      _$NotificationImpl _value, $Res Function(_$NotificationImpl) _then)
      : super(_value, _then);

  /// Create a copy of Notice
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NotificationImpl implements _Notification {
  const _$NotificationImpl();

  @override
  String toString() {
    return 'Notice.notification()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotificationImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() announcement,
    required TResult Function() notification,
    required TResult Function() warning,
    required TResult Function() following,
  }) {
    return notification();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? announcement,
    TResult? Function()? notification,
    TResult? Function()? warning,
    TResult? Function()? following,
  }) {
    return notification?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? announcement,
    TResult Function()? notification,
    TResult Function()? warning,
    TResult Function()? following,
    required TResult orElse(),
  }) {
    if (notification != null) {
      return notification();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Announcement value) announcement,
    required TResult Function(_Notification value) notification,
    required TResult Function(_Warning value) warning,
    required TResult Function(_Following value) following,
  }) {
    return notification(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Announcement value)? announcement,
    TResult? Function(_Notification value)? notification,
    TResult? Function(_Warning value)? warning,
    TResult? Function(_Following value)? following,
  }) {
    return notification?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Announcement value)? announcement,
    TResult Function(_Notification value)? notification,
    TResult Function(_Warning value)? warning,
    TResult Function(_Following value)? following,
    required TResult orElse(),
  }) {
    if (notification != null) {
      return notification(this);
    }
    return orElse();
  }
}

abstract class _Notification implements Notice {
  const factory _Notification() = _$NotificationImpl;
}

/// @nodoc
abstract class _$$WarningImplCopyWith<$Res> {
  factory _$$WarningImplCopyWith(
          _$WarningImpl value, $Res Function(_$WarningImpl) then) =
      __$$WarningImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WarningImplCopyWithImpl<$Res>
    extends _$NoticeCopyWithImpl<$Res, _$WarningImpl>
    implements _$$WarningImplCopyWith<$Res> {
  __$$WarningImplCopyWithImpl(
      _$WarningImpl _value, $Res Function(_$WarningImpl) _then)
      : super(_value, _then);

  /// Create a copy of Notice
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$WarningImpl implements _Warning {
  const _$WarningImpl();

  @override
  String toString() {
    return 'Notice.warning()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WarningImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() announcement,
    required TResult Function() notification,
    required TResult Function() warning,
    required TResult Function() following,
  }) {
    return warning();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? announcement,
    TResult? Function()? notification,
    TResult? Function()? warning,
    TResult? Function()? following,
  }) {
    return warning?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? announcement,
    TResult Function()? notification,
    TResult Function()? warning,
    TResult Function()? following,
    required TResult orElse(),
  }) {
    if (warning != null) {
      return warning();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Announcement value) announcement,
    required TResult Function(_Notification value) notification,
    required TResult Function(_Warning value) warning,
    required TResult Function(_Following value) following,
  }) {
    return warning(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Announcement value)? announcement,
    TResult? Function(_Notification value)? notification,
    TResult? Function(_Warning value)? warning,
    TResult? Function(_Following value)? following,
  }) {
    return warning?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Announcement value)? announcement,
    TResult Function(_Notification value)? notification,
    TResult Function(_Warning value)? warning,
    TResult Function(_Following value)? following,
    required TResult orElse(),
  }) {
    if (warning != null) {
      return warning(this);
    }
    return orElse();
  }
}

abstract class _Warning implements Notice {
  const factory _Warning() = _$WarningImpl;
}

/// @nodoc
abstract class _$$FollowingImplCopyWith<$Res> {
  factory _$$FollowingImplCopyWith(
          _$FollowingImpl value, $Res Function(_$FollowingImpl) then) =
      __$$FollowingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FollowingImplCopyWithImpl<$Res>
    extends _$NoticeCopyWithImpl<$Res, _$FollowingImpl>
    implements _$$FollowingImplCopyWith<$Res> {
  __$$FollowingImplCopyWithImpl(
      _$FollowingImpl _value, $Res Function(_$FollowingImpl) _then)
      : super(_value, _then);

  /// Create a copy of Notice
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$FollowingImpl implements _Following {
  const _$FollowingImpl();

  @override
  String toString() {
    return 'Notice.following()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FollowingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() announcement,
    required TResult Function() notification,
    required TResult Function() warning,
    required TResult Function() following,
  }) {
    return following();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? announcement,
    TResult? Function()? notification,
    TResult? Function()? warning,
    TResult? Function()? following,
  }) {
    return following?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? announcement,
    TResult Function()? notification,
    TResult Function()? warning,
    TResult Function()? following,
    required TResult orElse(),
  }) {
    if (following != null) {
      return following();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Announcement value) announcement,
    required TResult Function(_Notification value) notification,
    required TResult Function(_Warning value) warning,
    required TResult Function(_Following value) following,
  }) {
    return following(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Announcement value)? announcement,
    TResult? Function(_Notification value)? notification,
    TResult? Function(_Warning value)? warning,
    TResult? Function(_Following value)? following,
  }) {
    return following?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Announcement value)? announcement,
    TResult Function(_Notification value)? notification,
    TResult Function(_Warning value)? warning,
    TResult Function(_Following value)? following,
    required TResult orElse(),
  }) {
    if (following != null) {
      return following(this);
    }
    return orElse();
  }
}

abstract class _Following implements Notice {
  const factory _Following() = _$FollowingImpl;
}
